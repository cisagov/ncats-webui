import { Component, OnInit, OnDestroy } from '@angular/core';
import { Subscription } from 'rxjs/Rx';
import { CyhyDataService } from '../cyhy-data.service';
import { CyhyTitleService } from '../cyhy-title.service';
import { CyhyConfigService } from '../cyhy-config.service';
import { CyhyJsonDataSource } from '../cyhy-data-sources/cyhy-json-data-source';

import * as colorbrewer from 'colorbrewer';

// Bower loaded libraries, @types only.
import * as jQueryType from 'jquery';

// Importing d3 conflicts with status page. This is a workaround.
declare var d3: any;
declare var queue: any;
declare var topojson: any;
declare var $: typeof jQueryType;
declare var Foundation: any;

let self: any;

@Component({
  selector: 'app-vulnerability-map',
  templateUrl: './vulnerability-map.component.html',
  styleUrls: ['./vulnerability-map.component.css']
})
export class VulnerabilityMapComponent implements OnInit, OnDestroy {
  public static cycleName: string = 'VulnerabilityMapComponent';
  private svg: any;
  private path: any;
  private color: any;
  private hexbin: any;
  private scan_source: any;
  private severity_loop: any;
  private projection: any;
  private update_interval: any;
  private dataSource: CyhyJsonDataSource;
  private dataSubscription: Subscription;

  constructor(private titleService: CyhyTitleService, private config: CyhyConfigService, private cyhyDataService: CyhyDataService) {
    self = this;
  }

  ngOnInit() {
    this.titleService.setTitle('Active Map');
    self.severity_loop = [];

    let width = $('body').width() * 0.9;
    let height = $('body').height() - $('#map').offset().top;
    let parseDate = d3.time.format("%x").parse;

    let scale = 0;
    if (width < height) {
      scale = width;
    } else {
      scale = height;
    }

    if (Foundation.utils.is_medium_only()) {
      scale *= 1.2;
    } else if (Foundation.utils.is_large_only()) {
      scale *= 1.6;
    } else if (Foundation.utils.is_xlarge_up()) {
      scale *= 1.9;
    }

    $('#map').width(width);
    $('#map').height(height);

    self.color = d3.scale.linear()
      .domain([1,2,3,4])
      .range(["#5c90ba", "#cfc666", "#cf9c66", "#c66270"])

    self.hexbin = d3.hexbin()
        .size([width, height])
        .radius(16);

    let radius = d3.scale.sqrt()
        .domain([0, 12])
        .range([0, 8]);

    self.projection = d3.geo.albersUsa()
        .scale([scale])
        .translate([width / 2, height / 2])
        .precision(.1);

    self.path = d3.geo.path()
        .projection(self.projection);

    self.svg = d3.select("#map");

    queue()
      .defer(d3.json, "/assets/topo/us.json")
      .await(self.topo_ready);

    self.dataSource = new CyhyJsonDataSource(
      'Vulnerability Map',
      this.config.get('data_protocol'),
      this.config.get('data_host'),
      [this.config.get('data_path'), 'maps', 'active'],
      this.config.get('data_port'),
      'j&level=-1', 30000
    );
  }

  ngOnDestroy() {
    clearInterval(self.update_interval);
    self.dataSubscription.unsubscribe();
  }

  change_view_mode(severity){
      self.update_filter(severity);
      switch(severity)
      {
          case -1:
              self.severity_loop = [1, 2, 3, 4];
              break;
          case 0:
              self.severity_loop = [0];
              break;
          case 1:
              self.severity_loop = [1];
              break;
          case 2:
              self.severity_loop = [2];
              break;
          case 3:
              self.severity_loop = [3];
              break;
          case 4:
              self.severity_loop = [4];
              break;
      }
  }

  update_filter(severity) {
    // fetch new data
    self.dataSource.setParameters("j&level=" + severity).refreshData();
    // activate corresponding filter item
    document.getElementById("dd-critical").className = (severity == 4 ? "active" : "");
    document.getElementById("dd-high").className = (severity == 3 ? "active" : "");
    document.getElementById("dd-medium").className = (severity == 2 ? "active" : "");
    document.getElementById("dd-low").className = (severity == 1 ? "active" : "");
    document.getElementById("dd-all").className = (severity == 0 ? "active" : "");
  }

  topo_ready(error, us) {
    const promise = new Promise((resolve, reject) => {
      self.svg.append("path")
        .datum(topojson.feature(us, us.objects.land))
        .attr("class", "land")
        .attr("d", self.path);

      self.svg.append("path")
        .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
        .attr("class", "states")
        .attr("d", self.path);

      resolve();
    }).then(() => {
      self.change_view_mode(-1);

      let data = self.dataSource.getData();
      if (data) {
        self.update_hexes(false, data);
        self.isLoading = false;
      }

      self.dataSubscription = self.dataSource.subscribe(
          data => {
            if (data) {
              self.update_hexes(false, data);
              self.isLoading = false;
            }
          },
          error => console.warn(error)
      );

      self.update_interval = setInterval(() => {
        self.next_update();
      }, 15000);
    });
  }

  next_update(){
    let severity = self.severity_loop.shift();
    self.severity_loop.push(severity);
    self.update_filter(severity);
  }

  update_hexes(error, tickets) {
    if (tickets && tickets.length > 0) {
      var projected_tickets = [];
      tickets.forEach(function(d) {
        var p = self.projection(d.loc);
        if (p != null)
        {
          projected_tickets.push({0:p[0],1:p[1],"severity":d.details.severity})
        }
      });
      tickets = projected_tickets

      // Want to understand what is going on below?: http://bl.ocks.org/mbostock/3808218
      // DATA JOIN
      var node = self.svg.selectAll(".hexagons")
        .data(self.hexbin(tickets).sort(function(a, b) { return b.length - a.length; }))

      // UPDATE
      // Update old elements as needed.

      // noop

      // ENTER
      // Create new elements as needed.
      let enters = node.enter().append("g")
        .attr("class", "hexagons")
        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })

      enters.append("path")
        .attr("d", function(d) { return self.hexbin.hexagon(); })
        .style("fill-opacity", 0)
        .transition()
          .duration(750)
          .style("fill-opacity", 1)

      enters.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", ".35em")

      // ENTER + UPDATE
      // Appending to the enter selection expands the update selection to include
      // entering elements; so, operations on the update selection after appending to
      // the enter selection will apply to both entering and updating nodes.

      // set text and color of hex
      node.select("path")
        .style("fill", function(d) { return self.color(d3.median(d, function(d) { return +d.severity; })); })

      node.select("text")
        .text(function(d) { return d.length; })
        .style("font-size", function(d) {
          if (d.length < 100) return 16;
          if (d.length < 1000) return 12;
          return 10;
        })

      // EXIT
      // Remove old elements as needed.
      node.exit()
        .transition()
          .duration(750)
          .style("opacity", 0)
        .remove();
    }
  }
}
